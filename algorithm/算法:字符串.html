<!DOCTYPE html>
<html>

<head>
    <title>算法：字符串</title>
</head>

<body>
    <script>
        //字符串反转
        /*
            给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
            注意:
                假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个
                假设，如果反转后整数溢出那么就返回 0。
        */
        function reverseStr(data) {
            if (typeof(data) !== "number") {
                return 0;
            }

            //极值
            const MAX = 2147483647;
            const MIN = -2147483648;

            const str = data > 0 ? String(data).split("").reverse().join("") : String(data).slice(1).split("").reverse().join("");

            const result = data > 0 ? parseInt(str) : 0 - parseInt(str);

            if (result < MAX && result > MIN) {
                return result
            } else {
                return 0;
            }
        }

        // console.log("reverseStr=========", reverseStr(-12345))



        /*  我们借鉴欧几里得求最大公约数的方法来解题。
            符号的处理逻辑同方法一，这里我们通过模 10 取 到最低位，然后又通过乘 10 将最低位迭代到最高位，完成翻转。
            
            详解
                1. 设置边界极值;
                2. 取给定数值的绝对值，遍历循环生成每一位数字，借鉴欧几里得算法，从 num 的最后一位开
                始取值拼成新的数
                3. 同步剔除掉被消费的部分
                4. 如果最终结果为异常值，则直接返回 0;如果原本数据为负数，则对最终结果取反
                5. 返回最终结果

        */

        function reverseStr2(data) {
            if (typeof(data) !== "number") {
                return 0;
            }

            //极值
            const MAX = 2147483647;
            const MIN = -2147483648;

            const str = data > 0 ? String(data).split("").reverse().join("") : String(data).slice(1).split("").reverse().join("");

            const result = data > 0 ? (str) : 0 - parseInt(str);

            if (result < MAX && result > MIN) {
                return result
            } else {
                return 0;
            }
        }
    </script>
</body>

</html>